<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Riyas P</title>
    <description>Portfolio</description>
    <link>riyasyash.github.io/</link>
    <atom:link href="riyasyash.github.io/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Thu, 23 Apr 2020 16:25:09 +0530</pubDate>
    <lastBuildDate>Thu, 23 Apr 2020 16:25:09 +0530</lastBuildDate>
    <generator>Jekyll v3.8.5</generator>
    
      <item>
        <title>Monitoring Cassandra cluster with Prometheus Operator</title>
        <description>&lt;p&gt;Our current project has several microservices. All of them are dockerized and deployed to a Kubernetes ecosystem. There is a Cassandra cluster running outside the Kubernetes cluster and it is being used by most of our services.&lt;/p&gt;

&lt;p&gt;On the monitoring front, we have Prometheus Operator, beautiful Grafana dashboards and Loki to aggregate the logs generated by the services.&lt;/p&gt;

&lt;p&gt;All of these tools, namely Prometheus, Grafana, and Loki are also running within the Kuberenetes cluster. So it was pretty straightforward to set up and configure these for our services.&lt;/p&gt;

&lt;p&gt;Then came the task of monitoring the Cassandra cluster. Since it is running outside of Kubernetes cluster, we have to do the following things.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Export the metrics from the Cassandra cluster&lt;/li&gt;
  &lt;li&gt;Scrape the exported metrics from Cassandra nodes&lt;/li&gt;
  &lt;li&gt;Create a dashboard on Grafana with these metrics&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;step-1-export-the-metrics-from-the-cassandra-cluster&quot;&gt;Step 1: Export the metrics from the Cassandra cluster&lt;/h2&gt;

&lt;p&gt;We found this tool cassandra_exporter which is a fork of JMX exporter and is fairly easy to install and configure. Please go through the README of the project. Configure the metrics you want to export and the port on which you have to export those on all the nodes in the cluster.&lt;/p&gt;

&lt;p&gt;At the end of a successful configuration, you can get the metrics from your Cassandra node on &lt;code&gt;localhost:listenPort/&lt;/code&gt; or &lt;code&gt;localhost:listenPort/metrics&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;step-2-scrape-the-exported-metrics-from-cassandra-nodes&quot;&gt;Step 2: Scrape the exported metrics from Cassandra nodes&lt;/h2&gt;

&lt;p&gt;Implementing the monitoring for the Cassandra cluster became a little tricky since the Prometheus Operator runs within the Kubernetes cluster and the Kubernetes cluster doesnâ€™t know anything about the Cassandra cluster.&lt;/p&gt;

&lt;p&gt;Let me circle back to the above statement after diving into the Prometheus Operator.&lt;/p&gt;

&lt;h2 id=&quot;prometheus-operator&quot;&gt;Prometheus Operator&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;Operators were introduced by CoreOS as a class of software that operates other software, putting operational knowledge collected by humans into software. Read more in the original blog post, Introducing Operators. The Prometheus Operator serves to make running Prometheus on top of Kubernetes as easy as possible while preserving Kubernetes-native configuration options.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;To simplify the process of monitoring services in a Kubernetes cluster, the Prometheus Operator introduces additional resources:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Prometheus&lt;/li&gt;
  &lt;li&gt;ServiceMonitor&lt;/li&gt;
  &lt;li&gt;AlertManager&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;figure class=&quot;image&quot;&gt;&lt;center&gt;
    &lt;img src=&quot;https://miro.medium.com/max/1400/1*6KI8wlyWwLwPYgt_SP1CCA.png&quot; alt=&quot;src: https://coreos.com/operators/prometheus/docs/latest/user-guides/getting-started.html&quot; /&gt;
    &lt;figcaption&gt;src: https://coreos.com/operators/prometheus/docs/latest/user-guides/getting-started.html&lt;/figcaption&gt;
&lt;/center&gt;
  &lt;/figure&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;As evident from the architecture diagram, ServiceMonitor helps you to define how to group services for monitoring. Based on the ServiceMonitor definition Prometheus Operator creates the scrape configuration. This makes our job easier.&lt;/p&gt;

&lt;h2 id=&quot;problem&quot;&gt;Problem&lt;/h2&gt;

&lt;p&gt;This is excellent if the service is running inside the Kubernetes cluster, but the Cassandra cluster is running outside of it. Hence, there are no services or service definitions for the same and we cannot easily monitor them.&lt;/p&gt;

&lt;h2 id=&quot;workaround&quot;&gt;Workaround&lt;/h2&gt;

&lt;p&gt;Letâ€™s first implement a workaround for one node in the Cassandra cluster,&lt;/p&gt;

&lt;h3 id=&quot;create-a-kubernetes-endpoint-to-the-cassandra-node&quot;&gt;Create a Kubernetes endpoint to the Cassandra node&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-yaml&quot;&gt;
apiVersion: v1
kind: Endpoints
metadata:
    name: cassandra-metrics
    labels:
        release: prometheus-operator
    namespace: monitoring
subsets:
    - addresses:
      - ip: &amp;lt;ip address of the cassandra node&amp;gt;
      ports:
      - name: metrics
        port: 8080
        protocol: TCP

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;create-a-service-that-listens-to-this-endpoint&quot;&gt;Create a service that listens to this endpoint&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-yaml&quot;&gt;apiVersion: v1
kind: Service
metadata:
    name: cassandra-metrics
    namespace: monitoring
    labels:
        release: prometheus-operator
        k8s-app: cassandra-metrics
spec:
    type: ExternalName
    externalName: &amp;lt;ip address of the cassandra node&amp;gt;
    ports:
    - name: metrics
      port: 8080
      protocol: TCP
      targetPort: 8080

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;create-a-servicemonitor-that-will-monitor-the-above-service&quot;&gt;Create a ServiceMonitor that will monitor the above service&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-yaml&quot;&gt;apiVersion: monitoring.coreos.com/v1
kind: ServiceMonitor
metadata:
    name: cassandra-metrics-sm
    labels:
        release: prometheus-operator
        prometheus: kube-prometheus
    namespace: monitoring
spec:
    selector:
        matchLabels:
            release: prometheus-operator
            k8s-app: cassandra-metrics
        namespaceSelector:
            matchNames:
            - monitoring
    endpoints:
    - port: metrics
      interval: 10s
      honorLabels: true
      path: /metrics
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;At this point, you will be able to see the service monitor cassandra-metrics-sm under service discovery and targets in your Prometheus UI. Something like in the image below.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;figure class=&quot;image&quot;&gt;&lt;center&gt;
    &lt;img src=&quot;https://miro.medium.com/max/1400/1*VIHJaTlV_d96R1G2asR_cQ.png&quot; alt=&quot;&quot; /&gt;
    &lt;figcaption&gt;screenshot&lt;/figcaption&gt;
&lt;/center&gt;
  &lt;/figure&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;Now letâ€™s add more nodes from the Cassandra cluster to the ServiceMonitor. If you remember the architecture diagram above, this is a no brainer. We just have to create endpoints for remaining instances and create services to map to those endpoints. We donâ€™t have to create another ServiceMonitor since we need all the services to grouped under the same.&lt;/p&gt;

&lt;p&gt;If the configurations are complete you can see an increase in the number of active targets.&lt;/p&gt;

&lt;h2 id=&quot;step-3-create-the-grafana-dashboard&quot;&gt;Step 3: Create the Grafana Dashboard&lt;/h2&gt;

&lt;p&gt;There are lots of Grafana dashboards available online you can use any one of them including the one in cassandra_exporter documentation or you can create one of your own.&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;We discussed how we can use the Prometheus Operator running inside the Kubernetes cluster to monitor an externally running Cassandra cluster. We can use the same approach to monitor other services and instances as well. But remember to use a valid metrics exporter.&lt;/p&gt;
</description>
        <pubDate>Thu, 15 Aug 2019 05:30:01 +0530</pubDate>
        <link>riyasyash.github.io/blog/2019/monitoring-cassandra-with-prometheus-operator/</link>
        <guid isPermaLink="true">riyasyash.github.io/blog/2019/monitoring-cassandra-with-prometheus-operator/</guid>
        
        <category>tech</category>
        
        <category>Kubernetes</category>
        
        <category>Prometheus</category>
        
        <category>Cassandra</category>
        
        <category>Monitoring</category>
        
        <category>Grafana</category>
        
        
        <category>tech</category>
        
      </item>
    
      <item>
        <title>A Simple OAuth Provider</title>
        <description>&lt;p&gt;Recently, I had to implement an OAuth Provider for one of my projects (So that people can log in to a different application using their credentials on my app), which was using JWT token-based authentication. So I read through a lot of documentation and implementation models. Fortunately, since we were using django-rest-framework I could find a lot of good writeups. This is one among them Oauthlib.&lt;/p&gt;

&lt;p&gt;After reading the particular writeup, I decided to implement the provider our selves (since it seemed pretty simple, ðŸ˜…and it turned out simple too!)&lt;/p&gt;

&lt;p&gt;Here, we will be implementing OAuth through Authorization Code (Yeah, there are other methods as well.) The code will be more Django specific, but you can make use of the concepts and the models to implement the same in any other languages of your choice.&lt;/p&gt;

&lt;h2 id=&quot;how-is-it-working&quot;&gt;How is it working?&lt;/h2&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;figure class=&quot;image&quot;&gt;&lt;center&gt;
    &lt;img src=&quot;https://cdn-images-1.medium.com/max/1600/1*HcZ1gZ_7SbeY6V5h6N13Pw.jpeg&quot; alt=&quot;diagram depicting the authentication flow&quot; /&gt;
    &lt;figcaption&gt;diagram depicting the authentication flow&lt;/figcaption&gt;
&lt;/center&gt;
  &lt;/figure&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;The third party app (the application to which the user has to login) redirects to our authorization page with the client_id, that they get at the time of registration and optional success and error redirect URIs.&lt;br /&gt;&lt;br /&gt;&lt;/li&gt;
  &lt;li&gt;Our authorization page will validate whether a user is currently logged in or not (by checking the cookies). If there is a logged in user the page will ask the user for authorizing the access, if not the page will ask to log in with credentials. After that, the page requests our application backend to generate an authorization code for the client for the logged in user.&lt;br /&gt;&lt;br /&gt;&lt;/li&gt;
  &lt;li&gt;Our application backend ensures client and user validity and generates an authorization_code which expires in 10 minutes and responds with the code and redirect_uri (if any was registered with the client).&lt;br /&gt;&lt;br /&gt;&lt;/li&gt;
  &lt;li&gt;The authorization page redirects to the redirect_uri obtained from the application backend (or the success URI passed as the query parameter) with the authorization code.&lt;br /&gt;&lt;br /&gt;&lt;/li&gt;
  &lt;li&gt;The third party app requests our application backend to generate a user token with the obtained authorization_code, client_id, and client_secret obtained at the time of client registration.&lt;br /&gt;&lt;br /&gt;&lt;/li&gt;
  &lt;li&gt;The application backend validates the credentials and authorization code and generates a user token for the third party app.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;lets-begin&quot;&gt;Letâ€™s Begin&lt;/h2&gt;

&lt;p&gt;We need to write the CRUD APIs to register a client, update details for a client and delete a client (I will not be covering them hereðŸ¤“).&lt;/p&gt;

&lt;p&gt;We need two models to store the OAuth related data&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Client: Which will store the details of the third party application which has to access our appâ€™s data.&lt;/li&gt;
  &lt;li&gt;Authorization Code: Which will store the authorization_code, the user and client details for whom the code was generated and the expiry time of the particular authorization_code.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;We need to write functions to perform the following operations&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;To generate an authorization code after validating the client.&lt;/li&gt;
  &lt;li&gt;To generate the actual user token after validating the authorization code and client credentials&lt;/li&gt;
  &lt;li&gt;Optional function to invalidate the authorization code after generating the user token&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;lets-look-at-the-code&quot;&gt;Letâ€™s Look at the code&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;class AuthorizationCode(models.Model):
    client = models.ForeignKey(Client)
    user = models.ForeignKey(User)
    code = models.CharField(max_length=100, unique=True)
    expires_at = models.DateTimeField()
    class Meta:
        managed = True
    def generate_user_token(self):
        try:
            user = self.user
            token = function_to_generate_token(user) // replace with the function to generate the token
            self.invalidate()
            return token
        except:
            return False

    def invalidate(self):
        self.expires_at = datetime.datetime.now(datetime.timezone.utc)
        self.save()
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;class Client(models.Model):
    client_id = models.CharField(
        max_length=100, unique=True, default=generate_token, db_index=True
    )
    redirect_uri = models.TextField(
        blank=True
    )
    error_uri = models.TextField(
        blank=True
    )
    client_secret = models.CharField(
        max_length=255, blank=True, default=generate_client_secret, db_index=True
    )
    name = models.CharField(max_length=255, blank=True)
    class Meta:
        managed = True
    @classmethod
    def generate_auth_token(cls, client_id, client_secret, authorization_code):
        try:
            client = cls.objects.get(client_id=client_id, client_secret=client_secret)
            authorization_code = client.validate_auth_code(authorization_code)
            if authorization_code:
                return authorization_code.generate_user_token()
            return False
        except Exception as e:
            return False

    def validate_auth_code(self, authorization_code):
        authorization_code = self.authorizationcode_set.filter(code=authorization_code,
                                                                       expires_at__gte=datetime.datetime.now(
                                                                           datetime.timezone.utc)).first()
        return authorization_code
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;def generate_authorization_code(request, user):
    client_id = request.data.get('client_id')
    client = Client.objects.get(client_id=client_id)
    if client:
        authorization_code_data = create_authorization_code(request)
        authorization_code_data.update({'user': user.id, 'client': client.id})
        authorization_code_serializer = AuthorizationCodeSerializer(data=authorization_code_data)
        authorization_code_serializer.is_valid()
        authorization_code = authorization_code_serializer.save()
        return Response({
            'redirect_uri': client.redirect_uri,
            'authorization_code': authorization_code.code
        })
def create_authorization_code(request):
    &quot;&quot;&quot;Generates an authorization grant represented as a dictionary.&quot;&quot;&quot;
    now = datetime.datetime.now(datetime.timezone.utc)
    expires_at = now+datetime.timedelta(minutes=10)
    grant = {'code': generate_token(),'expires_at':expires_at}
    if hasattr(request, 'state') and request.state:
        grant['state'] = request.state
    return
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The functions generate_client_secret() and generate_token() can be any method that generates a random string with a length satisfying OAuth specification. The function_to_generate_token() has to be replaced with whatever you are using to generate user tokens (in my case it is JWT).&lt;/p&gt;

&lt;h2 id=&quot;thats-it&quot;&gt;Thatâ€™s it!&lt;/h2&gt;

&lt;p&gt;Now you know how an OAuth provider can be implemented!.&lt;/p&gt;
</description>
        <pubDate>Sun, 07 Oct 2018 05:30:00 +0530</pubDate>
        <link>riyasyash.github.io/blog/2018/a-simple-oauth-provider/</link>
        <guid isPermaLink="true">riyasyash.github.io/blog/2018/a-simple-oauth-provider/</guid>
        
        <category>tech</category>
        
        
        <category>tech</category>
        
      </item>
    
      <item>
        <title>Setting up SSH access from local machine to Google Cloud Compute engine</title>
        <description>&lt;p&gt;I am very much used to aws and I love the easiness of working with pem files and accessing the ec2 instances over ssh. Today I was trying to play around with Google Cloud Platform. It is very easy to bring up a compute engine (similar to aws ec2). Also the dashboard was similar to aws (but if you are used to aws terminology you might stumble across all the options google has).&lt;/p&gt;

&lt;p&gt;After setting up the instance I was going to connect from my local machine to the compute engine and then only I realised the absence of pem files, I didnâ€™t create any!, because they didnâ€™t prompt for one, because they donâ€™t have the concept of one.&lt;/p&gt;

&lt;p&gt;They do have a button in the machineâ€™s row on the compute engine dashboard called SSH. When you click on that, a new browser window will popup with a terminal on it. This is a fully functional terminal which you can use to setup, debug and monitor your compute engine. But I was not satisfied with it and I needed a way to use my local machine to connect to the compute engine (not through a browser window). Another reason I wanted it so badly was because it is easy to setup.&lt;/p&gt;

&lt;h2 id=&quot;lets-set-it-up&quot;&gt;Letâ€™s set it up!&lt;/h2&gt;

&lt;p&gt;I would like to split the entire process in to two sections, one to be performed on the local machine and the other on the Google Cloud Platform console.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;On your local machine:&lt;/b&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Open Terminal.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;$ ssh-keygen -t rsa -C [username] &lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;replace [username] with the value you need.&lt;/li&gt;
      &lt;li&gt;It will prompt you for a directory to place the files that are going to get generated (you can just hit ENTER and keep it to default).&lt;/li&gt;
      &lt;li&gt;Then it will prompt you for a passphrase (you can also hit ENTER and opt not to set a passphrase, but I would recommend it. Also I would recommend to remember it ðŸ˜‰).&lt;/li&gt;
      &lt;li&gt;If it is done there will be to new files generated under the directory you opted, by default it will be under â€˜.ssh/â€™ and will be named id_rsa and id_rsa.pub, this is a private-public key pair.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Now copy the id_rsa.pub (public key) and head over to the next section.&lt;/p&gt;

&lt;h2 id=&quot;on-google-cloud-console&quot;&gt;On Google cloud console:&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;Login to your account&lt;/li&gt;
  &lt;li&gt;Navigate to Compute Engine section&lt;/li&gt;
  &lt;li&gt;Select Metadata from the left side pane&lt;/li&gt;
  &lt;li&gt;Click on Edit&lt;/li&gt;
  &lt;li&gt;Click Add item and then paste the public key in to text box and hit Save.&lt;/li&gt;
  &lt;li&gt;Again select the option VM Instances from left pane&lt;/li&gt;
  &lt;li&gt;From the dashboard choose your machine&lt;/li&gt;
  &lt;li&gt;Click Edit&lt;/li&gt;
  &lt;li&gt;Under the section SSH Keys select show and edit and paste the public key again in the text box and hit Save&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;If everything is done right, you will be able to ssh in to the compute engine from your local machine ðŸ˜Žby &lt;code&gt;$ ssh -i id_rsa [username]@[public ip]&lt;/code&gt;&lt;/p&gt;

</description>
        <pubDate>Fri, 05 Oct 2018 05:30:00 +0530</pubDate>
        <link>riyasyash.github.io/blog/2018/ssh-to-google-cloud-machine/</link>
        <guid isPermaLink="true">riyasyash.github.io/blog/2018/ssh-to-google-cloud-machine/</guid>
        
        <category>tech</category>
        
        
        <category>tech</category>
        
      </item>
    
      <item>
        <title>Verifying your github commits using GPG key!</title>
        <description>&lt;p&gt;Today I got an email from a colleague. In the mail he had given the links to two blogs:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;https://nvisium.com/blog/2017/06/21/securing-github-commits-with-gpg-signing/&lt;/li&gt;
  &lt;li&gt;http://micropipes.com/blog//2016/08/31/signing-your-commits-on-github-with-a-gpg-key/&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;I read through those and came to know that verifying your git commits using GPG keys are very important (Please go ahead and prove me wrong ðŸ˜‰ ).&lt;/p&gt;

&lt;p&gt;So, I read through Github documentation on GPG keys and tried to set it up on my mac.&lt;/p&gt;

&lt;p&gt;There were some issuesâ€Šâ€”â€Šand I fixed them.&lt;/p&gt;

&lt;h2 id=&quot;lets-set-it-upfollow-me&quot;&gt;Letâ€™s set it upâ€Šâ€”â€ŠFollow me&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;For some random reason, my &lt;code&gt;gpg&lt;/code&gt; command was not working and finally when I fixed the prompt was in some different language (I guess it was SpanishðŸ˜‹). So I didnâ€™t use it to create the keys. I downloaded the GPG suite 2017.1 from here https://gpgtools.org/ .&lt;/li&gt;
  &lt;li&gt;It is a great tool, you can set up the gpg keys through the nice and easy UI.&lt;/li&gt;
  &lt;li&gt;The next step is to get the generated key, for this step, I used the command line tool (I donâ€™t care which language it is, I just want my keyðŸ˜Ž) Open your terminal and enter&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;$gpg --list-secret-keys --keyid-format LONG&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;This will list all the keys in your system.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Copy the GPG key id&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;$gpg --list-secret-keys --keyid-format LONG
/Users/hubot/.gnupg/secring.gpg
------------------------------------
sec 4096R/3AA5C34371567BD2 2016-03-10 [expires: 2017-03-10]
uid Hubot 
ssb 4096R/42B317FD4BA89E7A 2016-03-10
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In the example 3AA5C34371567BD2 is the id&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$gpg --armor --export 3AA5C34371567BD2&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Then letâ€™s copy the key, beginning withâ€Šâ€”â€Šâ€” -BEGIN PGP PUBLIC KEY BLOCKâ€Šâ€”â€Šâ€”â€Šâ€”â€Šand ending withâ€Šâ€”â€Šâ€” -END PGP PUBLIC KEY BLOCKâ€Šâ€”â€Šâ€” -&lt;/li&gt;
  &lt;li&gt;Now letâ€™s head over to github.com/settings/keys&lt;/li&gt;
  &lt;li&gt;click on the New GPG Key button, paste the entire key you copied and confirm.
You have successfully setup GPG key on your GitHub profile!!&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;signing-your-git-commits-with-gpg-key&quot;&gt;Signing your git commits with GPG key&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;Letâ€™s configure GPG signing in the git client, for that go to one of your local git repositories,&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;$git config gpg.program gpg
$git config commit.gpgsign true
$git config user.signingkey 3AA5C34371567BD2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now whenever you are commiting something to git you can use the option to sign with -S flag&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$git commit -S -m &quot;your commit message&quot;
$git push
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now you can see a very cool verified button in your commit line
That is it, optionally you can set all the above variables as global so that you donâ€™t have to do this for every repo
Please refer to following links for more details, they helped me a lot.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;https://help.github.com/articles/generating-a-new-gpg-key/&lt;/li&gt;
  &lt;li&gt;https://help.github.com/articles/adding-a-new-gpg-key-to-your-github-account/&lt;/li&gt;
  &lt;li&gt;https://help.github.com/articles/signing-commits-using-gpg/&lt;/li&gt;
  &lt;li&gt;https://stackoverflow.com/questions/39494631/gpg-failed-to-sign-the-data-fatal-failed-to-write-commit-object-git-2-10-0&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Thu, 04 Oct 2018 05:30:00 +0530</pubDate>
        <link>riyasyash.github.io/blog/2018/GPG-keys/</link>
        <guid isPermaLink="true">riyasyash.github.io/blog/2018/GPG-keys/</guid>
        
        <category>tech</category>
        
        
        <category>tech</category>
        
      </item>
    
  </channel>
</rss>
